<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BTC Up/Down Replay</title>
    <style>
      :root {
        --bg-a: #f3efe6;
        --bg-b: #dbe9f6;
        --panel: rgba(255, 255, 255, 0.8);
        --text: #102132;
        --muted: #4c5b6b;
        --line: rgba(16, 33, 50, 0.15);
        --accent: #d9480f;
        --btc: #1864ab;
        --up: #2b8a3e;
        --down: #c92a2a;
      }
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        color: var(--text);
        font-family: "Avenir Next", "PingFang SC", "Noto Sans CJK SC", "Segoe UI", sans-serif;
        background:
          radial-gradient(1200px 600px at 10% -10%, rgba(217, 72, 15, 0.15), transparent 60%),
          radial-gradient(1000px 500px at 100% 0%, rgba(24, 100, 171, 0.2), transparent 65%),
          linear-gradient(145deg, var(--bg-a), var(--bg-b));
      }
      .wrap {
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px 16px 28px;
      }
      .panel {
        background: var(--panel);
        border: 1px solid var(--line);
        border-radius: 14px;
        backdrop-filter: blur(6px);
      }
      .head {
        padding: 14px 16px;
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 10px 16px;
      }
      .title {
        margin: 0;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: 0.2px;
      }
      .sub {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 13px;
      }
      .controls {
        margin-top: 12px;
        padding: 14px 16px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
      }
      @media (max-width: 980px) {
        .controls {
          grid-template-columns: 1fr;
        }
      }
      .field {
        display: grid;
        gap: 6px;
      }
      .field label {
        font-size: 12px;
        color: var(--muted);
      }
      .field select,
      .field button {
        height: 38px;
        border-radius: 10px;
        border: 1px solid var(--line);
        padding: 0 10px;
        background: #fff;
        color: var(--text);
        font-size: 14px;
      }
      .field button {
        cursor: pointer;
        font-weight: 600;
        background: color-mix(in srgb, white 70%, #eaf1f8);
      }
      .stats {
        margin-top: 10px;
        padding: 0 16px 14px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chip {
        border: 1px solid var(--line);
        border-radius: 999px;
        padding: 5px 10px;
        background: rgba(255, 255, 255, 0.75);
        font-size: 12px;
        color: var(--muted);
      }
      .grid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      .ptb-wrap {
        margin-top: 12px;
        padding: 12px 14px 14px;
      }
      .ptb-title {
        margin: 4px 0 10px;
        font-size: 14px;
        color: var(--muted);
      }
      .ptb-meta {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chart-card {
        padding: 10px 12px 12px;
      }
      .chart-title {
        margin: 4px 0 8px;
        font-size: 14px;
        color: var(--muted);
      }
      .chart {
        width: 100%;
        height: 320px;
      }
      .empty {
        display: grid;
        place-items: center;
        height: 320px;
        color: var(--muted);
        border: 1px dashed var(--line);
        border-radius: 10px;
      }
      .intervals-wrap {
        margin-top: 12px;
        padding: 12px 14px 14px;
      }
      .intervals-title {
        margin: 4px 0 10px;
        font-size: 14px;
        color: var(--muted);
      }
      .intervals-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
        gap: 8px;
      }
      .interval-item {
        height: 44px;
        border-radius: 10px;
        border: 1px solid var(--line);
        background: rgba(255, 255, 255, 0.82);
        color: var(--text);
        cursor: pointer;
        font-size: 14px;
        text-align: left;
        padding: 0 10px;
      }
      .interval-item:hover {
        border-color: rgba(16, 33, 50, 0.35);
      }
      .interval-item.active {
        border-color: #1864ab;
        background: rgba(24, 100, 171, 0.1);
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <section class="panel head">
        <div>
          <h1 class="title">BTC 与 Up/Down 赔率回放</h1>
          <p class="sub">按 5 分钟时间段回看价格与赔率曲线</p>
        </div>
      </section>

      <section class="panel controls">
        <div class="field">
          <label for="dateSelect">日期（UTC 落盘目录）</label>
          <select id="dateSelect"></select>
        </div>
        <div class="field">
          <label for="refreshBtn">操作</label>
          <button id="refreshBtn" type="button">刷新区间列表</button>
        </div>
        <div class="field">
          <label for="showDownSelect">赔率线</label>
          <select id="showDownSelect">
            <option value="up-only">仅显示 UP（推荐）</option>
            <option value="up-down">显示 UP + DOWN</option>
          </select>
        </div>
        <div class="field">
          <label>状态</label>
          <div id="status" class="chip">初始化中...</div>
        </div>
      </section>

      <section class="panel intervals-wrap">
        <h2 class="intervals-title">5 分钟区间列表（点击加载图表）</h2>
        <div id="intervalList" class="intervals-list"></div>
      </section>

      <section class="panel stats" id="stats"></section>

      <section class="panel ptb-wrap">
        <h2 class="ptb-title">PTB（Price To Beat）信息</h2>
        <div id="ptbMeta" class="ptb-meta"></div>
      </section>

      <section class="grid">
        <article class="panel chart-card">
          <h2 class="chart-title">BTC/USD 价格（含 PTB）</h2>
          <div id="btcChart" class="chart"></div>
        </article>
        <article class="panel chart-card">
          <h2 class="chart-title">UP 概率（可选叠加 DOWN）</h2>
          <div id="oddsChart" class="chart"></div>
        </article>
      </section>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
    <script>
      const dateSelect = document.getElementById("dateSelect");
      const refreshBtn = document.getElementById("refreshBtn");
      const showDownSelect = document.getElementById("showDownSelect");
      const statusEl = document.getElementById("status");
      const statsEl = document.getElementById("stats");
      const intervalListEl = document.getElementById("intervalList");
      const ptbMetaEl = document.getElementById("ptbMeta");
      const btcContainer = document.getElementById("btcChart");
      const oddsContainer = document.getElementById("oddsChart");

      let intervals = [];
      let selectedIntervalIndex = -1;
      let btcChart = null;
      let oddsChart = null;

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function fmtTime(ms) {
        return new Date(ms).toLocaleString();
      }

      function fmtHm(ms) {
        const d = new Date(ms);
        return `${String(d.getHours()).padStart(2, "0")}:${String(d.getMinutes()).padStart(2, "0")}`;
      }

      function fmtHmRange(startMs, endMs) {
        return `${fmtHm(startMs)} - ${fmtHm(endMs)}`;
      }

      function renderStats(items) {
        statsEl.innerHTML = "";
        for (const text of items) {
          const el = document.createElement("div");
          el.className = "chip";
          el.textContent = text;
          statsEl.appendChild(el);
        }
      }

      function renderPtbMeta(items) {
        ptbMetaEl.innerHTML = "";
        for (const text of items) {
          const el = document.createElement("div");
          el.className = "chip";
          el.textContent = text;
          ptbMetaEl.appendChild(el);
        }
      }

      function fmtSec(ms) {
        const sec = Math.max(0, Math.round(Number(ms || 0) / 1000));
        return `${sec}s`;
      }

      async function fetchJson(url) {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return res.json();
      }

      function ensureCharts() {
        if (!window.echarts) {
          throw new Error("ECharts 未加载，无法绘图。");
        }
        if (!btcChart) btcChart = echarts.init(btcContainer);
        if (!oddsChart) oddsChart = echarts.init(oddsContainer);
        btcChart.group = "replay-group";
        oddsChart.group = "replay-group";
        echarts.connect("replay-group");
      }

      function normalizeOdds(v) {
        const n = Number(v);
        if (!Number.isFinite(n)) return null;
        if (n > 1.2) return n / 100;
        return n;
      }

      function mergeOddsSeries(upPointsRaw, downPointsRaw) {
        const upByTs = new Map();
        const downByTs = new Map();

        for (const p of upPointsRaw) {
          const ts = Number(p[0]);
          const v = normalizeOdds(p[1]);
          if (!Number.isFinite(ts) || v === null) continue;
          upByTs.set(ts, {
            value: v,
            slug: String(p[2] || ""),
            sampleCount: Number(p[3] || 1),
            eventType: String(p[4] || "")
          });
        }
        for (const p of downPointsRaw) {
          const ts = Number(p[0]);
          const v = normalizeOdds(p[1]);
          if (!Number.isFinite(ts) || v === null) continue;
          downByTs.set(ts, {
            value: v,
            slug: String(p[2] || ""),
            sampleCount: Number(p[3] || 1),
            eventType: String(p[4] || "")
          });
        }

        const allTs = Array.from(new Set([...upByTs.keys(), ...downByTs.keys()])).sort((a, b) => a - b);
        const up = [];
        const down = [];

        for (const ts of allTs) {
          const upRaw = upByTs.get(ts)?.value ?? null;
          const downRaw = downByTs.get(ts)?.value ?? null;
          const slug = upByTs.get(ts)?.slug || downByTs.get(ts)?.slug || "";
          const upSampleCount = upByTs.get(ts)?.sampleCount ?? null;
          const downSampleCount = downByTs.get(ts)?.sampleCount ?? null;
          const upEventType = upByTs.get(ts)?.eventType || "";
          const downEventType = downByTs.get(ts)?.eventType || "";

          const upVal = upRaw !== null ? upRaw : (downRaw !== null ? 1 - downRaw : null);
          const downVal = downRaw !== null ? downRaw : (upRaw !== null ? 1 - upRaw : null);

          if (upVal !== null) up.push([ts, upVal, slug, upSampleCount, upEventType]);
          if (downVal !== null) down.push([ts, downVal, slug, downSampleCount, downEventType]);
        }

        return { up, down };
      }

      function compactSeries(points, minTimeGapMs = 40, minValueGap = 0.0002) {
        if (!Array.isArray(points) || points.length <= 1) return points || [];
        const out = [];
        let lastTs = null;
        let lastVal = null;

        for (const point of points) {
          const ts = Number(point[0]);
          const val = Number(point[1]);
          if (!Number.isFinite(ts) || !Number.isFinite(val)) continue;
          if (lastTs === null) {
            out.push(point);
            lastTs = ts;
            lastVal = val;
            continue;
          }
          if ((ts - lastTs) >= minTimeGapMs || Math.abs(val - lastVal) >= minValueGap) {
            out.push(point);
            lastTs = ts;
            lastVal = val;
          }
        }
        const tail = points[points.length - 1];
        if (tail && (out.length === 0 || out[out.length - 1][0] !== tail[0] || out[out.length - 1][1] !== tail[1])) {
          out.push(tail);
        }
        return out;
      }

      function oddsPointToValue(point) {
        return [point[0], point[1], point[2] || "", point[3] || 1, point[4] || ""];
      }

      function compactPriceSeries(points, minTimeGapMs = 100, minValueGap = 0.2) {
        if (!Array.isArray(points) || points.length <= 1) return points || [];
        const out = [];
        let lastTs = null;
        let lastVal = null;
        for (const p of points) {
          const ts = Number(p[0]);
          const v = Number(p[1]);
          if (!Number.isFinite(ts) || !Number.isFinite(v)) continue;
          if (lastTs === null) {
            out.push(p);
            lastTs = ts;
            lastVal = v;
            continue;
          }
          if ((ts - lastTs) >= minTimeGapMs || Math.abs(v - lastVal) >= minValueGap) {
            out.push(p);
            lastTs = ts;
            lastVal = v;
          }
        }
        const tail = points[points.length - 1];
        if (tail && (out.length === 0 || out[out.length - 1][0] !== tail[0] || out[out.length - 1][1] !== tail[1])) {
          out.push(tail);
        }
        return out;
      }

      function draw(series, interval) {
        ensureCharts();
        const btcPoints = Array.isArray(series.btc) ? series.btc : [];
        const ptbPointsRaw = Array.isArray(series.ptb) ? series.ptb : [];
        const ptbPoints = compactPriceSeries(
          ptbPointsRaw.map((x) => [x[0], x[1], x[2] || "", x[3] ?? null, x[4] ?? null]),
          100,
          0.01
        );
        const latestPtbPrice = ptbPointsRaw.length ? Number(ptbPointsRaw[ptbPointsRaw.length - 1][1]) : null;
        const upPointsRaw = Array.isArray(series.up) ? series.up : [];
        const downPointsRaw = Array.isArray(series.down) ? series.down : [];
        const merged = mergeOddsSeries(upPointsRaw, downPointsRaw);
        const upPoints = compactSeries(merged.up);
        const downPoints = compactSeries(merged.down);
        const showDown = showDownSelect.value === "up-down";

        const zoomStart = 0;
        const zoomEnd = 100;

        btcChart.setOption({
          animation: false,
          grid: { left: 86, right: 56, top: 24, bottom: 55, containLabel: true },
          tooltip: {
            trigger: "axis",
            formatter: (params) => {
              if (!params || params.length === 0) return "";
              const ts = params[0].value[0];
              const lines = [`<b>${fmtTime(ts)}</b>`];
              for (const p of params) {
                const val = Number(p.value[1]);
                if (p.seriesName === "PTB") {
                  const method = p.value[2] || "-";
                  lines.push(`${p.marker}${p.seriesName}: ${val.toFixed(2)} [${method}]`);
                } else {
                  lines.push(`${p.marker}${p.seriesName}: ${val.toFixed(2)}`);
                }
              }
              return lines.join("<br/>");
            }
          },
          xAxis: { type: "time" },
          yAxis: {
            type: "value",
            scale: true,
            axisLabel: { formatter: (v) => Number(v).toFixed(2) }
          },
          dataZoom: [
            { type: "inside", start: zoomStart, end: zoomEnd },
            { type: "slider", start: zoomStart, end: zoomEnd, height: 18, bottom: 8 }
          ],
          series: [
            {
              name: "BTC",
              type: "line",
              showSymbol: false,
              smooth: 0.06,
              itemStyle: { color: "#1864ab" },
              lineStyle: { width: 2, color: "#1864ab" },
              markLine: Number.isFinite(latestPtbPrice)
                ? {
                  symbol: "none",
                  silent: true,
                  label: {
                    show: true,
                    position: "insideStartTop",
                    formatter: `PTB ${latestPtbPrice.toFixed(2)}`,
                    color: "#d9480f",
                    padding: [2, 4],
                    backgroundColor: "rgba(255,255,255,0.72)"
                  },
                  lineStyle: {
                    type: "dashed",
                    width: 1.8,
                    color: "#d9480f",
                    opacity: 0.9
                  },
                  data: [{ yAxis: latestPtbPrice }]
                }
                : undefined,
              data: btcPoints
            },
            {
              name: "PTB",
              type: "line",
              showSymbol: false,
              smooth: false,
              itemStyle: { color: "#d9480f" },
              lineStyle: { width: 2.8, color: "#d9480f" },
              data: ptbPoints
            }
          ]
        }, true);

        oddsChart.setOption({
          animation: false,
          grid: { left: 72, right: 28, top: 20, bottom: 55, containLabel: true },
          tooltip: {
            trigger: "axis",
            formatter: (params) => {
              if (!params || params.length === 0) return "";
              const ts = params[0].value[0];
              const lines = [`<b>${fmtTime(ts)}</b>`];
              for (const p of params) {
                const val = p.value[1];
                const slug = p.value[2] || "";
                const sampleCount = Number(p.value[3] || 1);
                const eventType = p.value[4] || "";
                lines.push(
                  `${p.marker}${p.seriesName}: ${Number(val).toFixed(4)}`
                  + `${slug ? ` (${slug})` : ""}`
                  + `${eventType ? ` [${eventType}]` : ""}`
                  + ` x${sampleCount}`
                );
              }
              return lines.join("<br/>");
            }
          },
          xAxis: { type: "time" },
          yAxis: {
            type: "value",
            min: 0,
            max: 1,
            axisLabel: { formatter: (v) => Number(v).toFixed(2) }
          },
          dataZoom: [
            { type: "inside", start: zoomStart, end: zoomEnd },
            { type: "slider", start: zoomStart, end: zoomEnd, height: 18, bottom: 8 }
          ],
          series: [
            {
              name: "UP",
              type: "line",
              showSymbol: false,
              smooth: 0.06,
              itemStyle: { color: "#2b8a3e" },
              lineStyle: { width: 1.8, color: "#2b8a3e" },
              markLine: {
                symbol: "none",
                label: { formatter: "0.50 分界" },
                lineStyle: { type: "dashed", color: "rgba(0,0,0,0.3)" },
                data: [{ yAxis: 0.5 }]
              },
              data: upPoints.map(oddsPointToValue)
            },
            {
              name: "DOWN",
              show: showDown,
              type: "line",
              showSymbol: false,
              smooth: 0.06,
              itemStyle: { color: "#c92a2a" },
              lineStyle: { width: 1.8, color: "#c92a2a" },
              data: downPoints.map(oddsPointToValue)
            }
          ]
        }, true);

        const updownGap = (upPoints.length && downPoints.length)
          ? `UP范围: ${Math.min(...upPoints.map((x) => x[1])).toFixed(3)}~${Math.max(...upPoints.map((x) => x[1])).toFixed(3)}`
          : "UP范围: -";

        const ptbMethods = Array.from(new Set(ptbPointsRaw.map((x) => String(x[2] || "")).filter(Boolean)));
        const latestPtb = ptbPointsRaw.length ? ptbPointsRaw[ptbPointsRaw.length - 1] : null;
        renderPtbMeta([
          `PTB 点数: ${ptbPointsRaw.length}`,
          `PTB 方法: ${ptbMethods.length ? ptbMethods.join("/") : "-"}`,
          `最新 PTB: ${latestPtb ? Number(latestPtb[1]).toFixed(2) : "-"}`,
          `最新 PTB 时间: ${latestPtb ? fmtTime(latestPtb[0]) : "-"}`
        ]);

        renderStats([
          `区间: ${interval.label}`,
          `市场: ${interval.marketSlug || "-"}`,
          `开始: ${fmtTime(interval.startMs)}`,
          `结束: ${fmtTime(interval.endMs)}`,
          `BTC 点数: ${btcPoints.length}`,
          `UP 点数: ${upPoints.length}`,
          `DOWN 点数: ${downPoints.length}`,
          `UP 聚合样本: ${interval.upSampleCount || 0}`,
          `DOWN 聚合样本: ${interval.downSampleCount || 0}`,
          `BTC 覆盖: ${fmtSec(interval.btcCoverageMs)}`,
          `赔率覆盖: ${fmtSec(interval.oddsCoverageMs)}`,
          `完整区间: ${interval.isComplete ? "是" : "否"}`,
          updownGap
        ]);
      }

      async function loadSeriesBySelectedInterval() {
        const idx = Number(selectedIntervalIndex);
        const interval = intervals[idx];
        if (!interval) {
          setStatus("当前日期没有可用区间");
          renderStats(["无可用区间"]);
          renderPtbMeta(["PTB 点数: 0", "PTB 方法: -", "最新 PTB: -", "最新 PTB 时间: -"]);
          return;
        }
        setStatus("加载序列中...");
        const marketSlugParam = interval.marketSlug ? `&marketSlug=${encodeURIComponent(interval.marketSlug)}` : "";
        const windowIdParam = interval.windowId ? `&windowId=${encodeURIComponent(interval.windowId)}` : "";
        const dateParam = dateSelect.value ? `&date=${encodeURIComponent(dateSelect.value)}` : "";
        const series = await fetchJson(
          `/api/series?startMs=${interval.startMs}&endMs=${interval.endMs}${marketSlugParam}${windowIdParam}${dateParam}`
        );
        draw(series, interval);
        setStatus("已加载");
      }

      async function chooseInterval(idx) {
        selectedIntervalIndex = idx;
        renderIntervalList();
        await loadSeriesBySelectedInterval();
      }

      function renderIntervalList() {
        intervalListEl.innerHTML = "";
        if (!Array.isArray(intervals) || intervals.length === 0) {
          const empty = document.createElement("div");
          empty.className = "chip";
          empty.textContent = "当前日期无可用5分钟区间";
          intervalListEl.appendChild(empty);
          return;
        }
        intervals.forEach((item, idx) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = `interval-item${idx === selectedIntervalIndex ? " active" : ""}`;
          btn.textContent = fmtHmRange(item.startMs, item.endMs);
          btn.title = `${item.label}${item.windowId ? ` | ${item.windowId}` : ""}`;
          btn.addEventListener("click", async () => {
            await chooseInterval(idx);
          });
          intervalListEl.appendChild(btn);
        });
      }

      function pickDefaultIntervalIndex(list) {
        if (!Array.isArray(list) || list.length === 0) return -1;
        for (let i = list.length - 1; i >= 0; i -= 1) {
          if (list[i].isComplete) return i;
        }
        let bestIdx = 0;
        let bestScore = -1;
        for (let i = 0; i < list.length; i += 1) {
          const btcCov = Number(list[i].btcCoverageMs || 0);
          const oddsCov = Number(list[i].oddsCoverageMs || 0);
          const score = Math.min(btcCov, oddsCov);
          if (score >= bestScore) {
            bestScore = score;
            bestIdx = i;
          }
        }
        return bestIdx;
      }

      async function loadIntervals(date, autoSelectLast = true) {
        setStatus("加载区间中...");
        const data = await fetchJson(`/api/intervals?date=${encodeURIComponent(date)}`);
        intervals = Array.isArray(data.intervals) ? data.intervals : [];
        selectedIntervalIndex = -1;
        renderIntervalList();
        if (intervals.length === 0) {
          setStatus("当前日期没有可视化交集区间");
          renderStats([`日期 ${date} 无区间`]);
          renderPtbMeta(["PTB 点数: 0", "PTB 方法: -", "最新 PTB: -", "最新 PTB 时间: -"]);
          return;
        }
        if (autoSelectLast) {
          const idx = pickDefaultIntervalIndex(intervals);
          selectedIntervalIndex = idx >= 0 ? idx : intervals.length - 1;
        }
        renderIntervalList();
        await loadSeriesBySelectedInterval();
      }

      async function bootstrap() {
        try {
          setStatus("加载日期列表中...");
          const data = await fetchJson("/api/dates");
          const dates = Array.isArray(data.dates) ? data.dates : [];
          dateSelect.innerHTML = "";
          for (const date of dates) {
            const option = document.createElement("option");
            option.value = date;
            option.textContent = date;
            dateSelect.appendChild(option);
          }
          if (dates.length === 0) {
            setStatus("未找到 logs/raw 下的日期数据");
            renderStats(["请先运行采集器生成数据"]);
            renderPtbMeta(["PTB 点数: 0", "PTB 方法: -", "最新 PTB: -", "最新 PTB 时间: -"]);
            return;
          }
          dateSelect.value = dates[0];
          await loadIntervals(dates[0], true);
        } catch (err) {
          setStatus(`初始化失败: ${err.message || err}`);
          renderStats(["接口不可用或数据格式异常"]);
        }
      }

      refreshBtn.addEventListener("click", async () => {
        if (!dateSelect.value) return;
        await loadIntervals(dateSelect.value, true);
      });

      dateSelect.addEventListener("change", async () => {
        if (!dateSelect.value) return;
        await loadIntervals(dateSelect.value, true);
      });

      showDownSelect.addEventListener("change", async () => {
        await loadSeriesBySelectedInterval();
      });

      window.addEventListener("resize", () => {
        btcChart?.resize();
        oddsChart?.resize();
      });

      bootstrap();
    </script>
  </body>
</html>
